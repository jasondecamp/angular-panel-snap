{"version":3,"sources":["module.js","menu.js","angular-panel-snap.min.js","panel-group.js","panel.js","scroll.js"],"names":["angular","module","akPanelGroupMenu","$rootScope","$log","restrict","template","scope","for","link","isDefined","panels","$on","event","data","group","stopPropagation","panel","id","name","active","push","forEach","select","$emit","error","directive","$inject","akPanelGroup","replace","controller","speed","threshold","fullWindow","keyboard","prevKey","nextKey","snap","init","panelGroupController","$scope","$element","$attrs","$window","$timeout","$document","bind","ctrl","eventContainer","on","scrollFn","enabled","touchstart","e","originalEvent","touches","clientY","preventDefault","isSnapping","type","delta","Math","max","min","wheelDelta","detail","snapToPanel","currentPanel","touchend","changedTouches","element","resize","keydown","which","scrollStop","cancel","scrollTimeout","resizeTimeout","scrollInterval","isNaN","container","innerHeight","clientHeight","target","offset","snapContainer","scrollTop","i","position","$apply","activatePanel","scrollDifference","scrollOffset","maxOffset","scrollHeight","floor","ceil","round","length","$broadcast","onLeave","scrollTarget","scrollTo","then","onEnter","setActive","this","addPanel","panelScope","panelName","enableSnap","disableSnap","toggleSnap","snapTo","documentElement","document","unbind","akPanel","require","transclude","attrs","css","width","height","onResize","$","top","window","scrollEasing","x","pow","runFn","$q","cancelAnimation","requestAnimation","proto","prototype","isDocument","el","HTMLDocument","nodeType","DOCUMENT_NODE","isElement","HTMLElement","ELEMENT_NODE","unwrap","left","duration","aliasFn","scrollToElement","scrollToAnimated","apply","arguments","scrollLeft","easing","scrollAnimation","deferred","startLeft","startTop","deltaLeft","deltaTop","startTime","cancelOnEvents","cancelScrollAnimation","$event","reject","defer","resolve","promise","animationStep","timestamp","progress","percent","getBoundingClientRect","overloaders","value","isNumber","scrollX","body","scrollY","overloadScrollPos","superFn","overloadFn","methodName","polyfill","vendors","fnName","fallback","key","suffix","substr","toUpperCase","lastTime","callback","currTime","Date","getTime","timeToCall","run","factory"],"mappings":"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","file":"angular-panel-snap.min.js","sourcesContent":["(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('panel-snap', []);\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n  return {\n    restrict: 'EA',\n    template: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n    scope: {\n      for: '@'\n    },\n    link: function (scope) {\n      if (!angular.isDefined(scope.for)) {\n        $log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n        return;\n      }\n\n      scope.panels = [];\n\n      /*\n       * listen for addedPanel event, if group name matches then add\n       * it to the menu\n       */\n      $rootScope.$on('panelsnap:addedPanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          var panel = {\n            id: data.id,\n            name: data.name,\n            active: false\n          };\n          scope.panels.push(panel);\n        }\n      });\n\n      /*\n       * listen for activatePanel event, if group name matches then set\n       * active flag target menu element\n       */\n      $rootScope.$on('panelsnap:activatePanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          angular.forEach(scope.panels, function (panel) {\n            panel.active = false;\n          });\n          scope.panels[data.id].active = true;\n        }\n      });\n\n      /*\n       * emit event to tell ak-panel-group directive to select the target panel\n       */\n      scope.select = function (id) {\n        $rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n      };\n    }\n  };\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * angular-panel-snap main module definition\n */\nangular.module('panel-snap', []);\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group-menu directive\n *\n * Creates a menu for the referenced ak-panel-group container\n *\n * @attribute for (required) String: name attribute of the ak-panel-group the menu is to reference\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroupMenu', akPanelGroupMenu);\n\n/* @ngInject */\nfunction akPanelGroupMenu ($rootScope, $log) {\n  return {\n    restrict: 'EA',\n    template: '<ul class=\"ak-menu\"><li ng-repeat=\"panel in panels\" ng-class=\"{active: panel.active}\" ng-click=\"select(panel.id)\"><a href>{{panel.name}}</a></li></ul>',\n    scope: {\n      for: '@'\n    },\n    link: function (scope) {\n      if (!angular.isDefined(scope.for)) {\n        $log.error(\"PanelGroupMenu: no 'for' attribute provided\");\n        return;\n      }\n\n      scope.panels = [];\n\n      /*\n       * listen for addedPanel event, if group name matches then add\n       * it to the menu\n       */\n      $rootScope.$on('panelsnap:addedPanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          var panel = {\n            id: data.id,\n            name: data.name,\n            active: false\n          };\n          scope.panels.push(panel);\n        }\n      });\n\n      /*\n       * listen for activatePanel event, if group name matches then set\n       * active flag target menu element\n       */\n      $rootScope.$on('panelsnap:activatePanel', function (event, data) {\n        if (scope.for === data.group) {\n          event.stopPropagation();\n          angular.forEach(scope.panels, function (panel) {\n            panel.active = false;\n          });\n          scope.panels[data.id].active = true;\n        }\n      });\n\n      /*\n       * emit event to tell ak-panel-group directive to select the target panel\n       */\n      scope.select = function (id) {\n        $rootScope.$emit('panelsnap:selectPanel', {group: scope.for, id: id});\n      };\n    }\n  };\n}\nakPanelGroupMenu.$inject = [\"$rootScope\", \"$log\"];\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px\n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n * @attribute snap (optional) Boolean: enable or disable the snapping on initialization\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroup', akPanelGroup)\n  .controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    controller: 'PanelGroupController',\n    scope: {\n      name: '@',\n      speed: '=',\n      threshold: '=',\n      fullWindow: '=',\n      keyboard: '=',\n      prevKey: '=',\n      nextKey: '=',\n      snap: '='\n    },\n    link: function (scope) {\n      // Call init after child panels have registered with the controller\n      scope.init();\n    }\n  };\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n  var ctrl = this;\n\n  var resizeTimeout;\n  var scrollTimeout;\n\n  ctrl.panels = [];\n\n  ctrl.currentPanel = 0;\n  ctrl.scrollInterval = 0;\n  ctrl.scrollOffset = 0;\n  ctrl.isSnapping = false;\n  ctrl.enabled = true;\n\n  ctrl.speed = 400;   // default snap animation duration in milliseconds\n  ctrl.threshold = 50;  // default pixel threshold for snap to occur in pixels\n  ctrl.prevKey = 38;    // default prevKey key code - up arrow\n  ctrl.nextKey = 40;    // default nextKey key code - down arrow\n\n  /*\n   * add a panels scope to the panels array\n   * - attached to `this` so it can be called from child panel directives\n   */\n  ctrl.addPanel = function (panelScope) {\n    var panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n    ctrl.panels.push(panelScope);\n    if (angular.isDefined($scope.name)) {\n      $rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n    }\n  };\n\n  /*\n   * enable snapping\n   */\n  ctrl.enableSnap = function () {\n    // TODO: should this snap to closest panel when enabled? (yes)\n    ctrl.enabled = true;\n  };\n\n  /*\n   * disable snapping\n   */\n  ctrl.disableSnap = function () {\n    ctrl.enabled = false;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.toggleSnap = function () {\n    ctrl.enabled = !ctrl.enabled;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.snapTo = function (id) {\n    snapToPanel(id);\n  };\n\n  /*\n   * initialise the controller state\n   * - called from the directive link function. This ensures it is called after any child panels\n   *  link function has called addPanel and therefore the panels array is filled and valid.\n   */\n  $scope.init = function () {\n    ctrl.container = $element;\n    ctrl.eventContainer = ctrl.container;\n    ctrl.snapContainer = ctrl.container;\n\n    // if full window, bind and snap using document instead of element\n    if ($scope.fullWindow) {\n      ctrl.container = angular.element($document[0].documentElement);\n      ctrl.eventContainer = ctrl.snapContainer = $document;\n    }\n\n    // set options / variables\n    ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n    ctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n    ctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n    ctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n    ctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n    ctrl.enabled = angular.isDefined($scope.snap) ? $scope.snap : ctrl.enabled;\n\n    bind();\n    $timeout(function() {\n      activatePanel(ctrl.currentPanel);\n    },0);\n  };\n\n  /*\n   * listen for selectPanel event, if group name matches then snap\n   * to the target panel\n   */\n  $rootScope.$on('panelsnap:selectPanel', function (event, data) {\n    if ($scope.name === data.group) {\n      event.stopPropagation();\n      snapToPanel(data.id);\n    }\n  });\n\n  $scope.$on('$destroy',function(){\n    angular.element(document).unbind('.panelsnap');\n  });\n\n  function bind() {\n    // bind scrolling events\n    ctrl.eventContainer.on('scroll.panelsnap', scrollFn);\n\n    // bind scrolling events\n    if(ctrl.enabled) {\n      // touch move direction support\n      var touchstart;\n      ctrl.eventContainer.on('touchstart.panelsnap', function(e) {\n        touchstart = e.originalEvent.touches[0].clientY;\n      });\n      ctrl.eventContainer.on('mousewheel.panelsnap touchmove.panelsnap DOMMouseScroll.panelsnap', function(e) {\n        e.preventDefault();\n        if(ctrl.isSnapping) return false;\n        if(e.type==='mousewheel'||e.type==='DOMMouseScroll') {\n          var delta = Math.max(-1, Math.min(1, (e.originalEvent.wheelDelta || -e.originalEvent.detail)));\n          if(delta && delta > 0) snapToPanel(ctrl.currentPanel - 1);\n          else if(delta) snapToPanel(ctrl.currentPanel + 1);\n        } else if(e.type==='touchmove') {\n          var touchend = e.originalEvent.changedTouches[0].clientY;\n          if(touchstart < touchend) snapToPanel(ctrl.currentPanel - 1);\n          else snapToPanel(ctrl.currentPanel + 1);\n          touchstart = touchend;\n        }\n      });\n    }\n\n    // bind resize event\n    angular.element($window).on('resize.panelSnap', resize);\n\n    // bind keyboard events\n    if ($scope.keyboard) {\n      angular.element($window).on('keydown.panelSnap', keydown);\n    }\n  }\n\n  function keydown(e) {\n    if (!ctrl.enabled) {\n      return;\n    }\n\n    // prevent any keypress events while snapping\n    if (ctrl.isSnapping) {\n      if (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n        e.preventDefault();\n        return false;\n      }\n      return;\n    }\n\n    switch (e.which) {\n      case ctrl.prevKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel - 1);\n        break;\n      case ctrl.nextKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel + 1);\n        break;\n    }\n  }\n\n  function scrollFn() {\n    if (!ctrl.enabled) scrollStop();\n    $timeout.cancel(scrollTimeout);\n    scrollTimeout = $timeout(function () {\n      scrollStop();\n    }, 50);\n  }\n\n  function resize() {\n    var threshold = 150;\n    $timeout.cancel(resizeTimeout);\n    resizeTimeout = $timeout(function () {\n      ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\n      if (!ctrl.enabled) {\n        return;\n      }\n\n      // snap back to current panel after resizing\n      snapToPanel(ctrl.currentPanel);\n    }, threshold);\n  }\n\n  function scrollStop() {\n\n    // if (ctrl.isMouseDown) {\n    //  return;\n    // }\n\n    if (ctrl.isSnapping) {\n      return;\n    }\n\n    var target;\n    var offset = ctrl.snapContainer.scrollTop();\n\n\n    // still want to activate the correct panel even if snapping is disabled\n    angular.forEach(ctrl.panels, function(panel,i) { if(panel.position < offset + ctrl.scrollInterval/2) target = i; });\n    if (target !== ctrl.currentPanel) $scope.$apply(activatePanel(target));\n    if (!ctrl.enabled) return true;\n\n    var scrollDifference = offset - ctrl.scrollOffset;\n    var maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n    // determine target panel\n    if (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n      target = Math.floor(offset / ctrl.scrollInterval);\n    } else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n      target = Math.ceil(offset / ctrl.scrollInterval);\n    } else {\n      target = Math.round(offset / ctrl.scrollInterval);\n    }\n\n    // ensure target is within panel array bounds\n    target = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n    if (scrollDifference === 0) {\n      // Do nothing\n    } else if (offset <= 0 || offset >= maxOffset) {\n      // only activate to prevent stuttering\n      activatePanel(target);\n      // set a scrollOffset to a sane number for next scroll\n      ctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n    } else {\n      snapToPanel(target);\n    }\n  }\n\n  function snapToPanel(target) {\n    if (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n      return;\n    }\n\n    ctrl.isSnapping = true;\n\n    $rootScope.$broadcast('panelsnap:start', { group: $scope.name, id: target });\n    $timeout(function() { // lets the broadcast get processed before continuing\n      ctrl.panels[ctrl.currentPanel].onLeave();\n\n      var scrollTarget = ctrl.scrollInterval * target;\n      ctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n        ctrl.scrollOffset = scrollTarget;\n        $timeout(function(){\n          ctrl.isSnapping = false;\n        },300);\n\n\n        $rootScope.$broadcast('panelsnap:finish', { group: $scope.name, id: target });\n        ctrl.panels[target].onEnter();\n\n        activatePanel(target);\n      });\n    },0);\n  }\n\n  function activatePanel(target) {\n    // if no panels, or panels have not yet loaded (within ng-repeat) return\n    if (!ctrl.panels || ctrl.panels.length < 1) {\n      return;\n    }\n\n    angular.forEach(ctrl.panels, function (panel) {\n      panel.setActive(false);\n    });\n    ctrl.panels[target].setActive(true);\n    ctrl.currentPanel = target;\n\n    // TODO: call onActivate function for target\n    $rootScope.$broadcast('panelsnap:activate', {group: $scope.name, id: target });\n    $rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n  }\n}\npanelGroupController.$inject = [\"$scope\", \"$element\", \"$attrs\", \"$window\", \"$timeout\", \"$document\", \"$rootScope\"];\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n  .module('panel-snap')\n  .directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n  return {\n    restrict: 'EA',\n    require: '^akPanelGroup',\n    replace: true,\n    transclude: true,\n    scope: {\n      name: '@',\n      onEnter: '&',\n      onLeave: '&'\n    },\n    template: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n    link: function (scope, element, attrs, ctrl) {\n\n      // add to parent ak-panel-group\n      ctrl.addPanel(scope);\n\n      // default panel styles\n      element.css({\n        'width': '100%',\n        'height': '100%',\n        'position': 'relative'\n      });\n\n      // attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n      scope.enableSnap = ctrl.enableSnap;\n      scope.disableSnap = ctrl.disableSnap;\n      scope.toggleSnap = ctrl.toggleSnap;\n      scope.snapTo = ctrl.snapTo;\n\n      // active flag and getter function, to set class .active on panel\n      scope.active = false;\n      scope.setActive = function (active) {\n        scope.active = active;\n      };\n\n      var onResize = function() {\n        // TODO replace jQuery offset here\n        scope.position = $(element).offset().top;\n      };\n      onResize();\n\n      // bind resize event\n      angular.element(window).on('resize', onResize);\n      scope.$on('$destroy',function(){\n        angular.element(window).unbind('resize', onResize);\n      });\n\n    }\n  };\n}\n\n\n})();\n\n(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n  .module('panel-snap')\n  .value('scrollEasing', scrollEasing)\n  .run(runFn)\n  .factory('polyfill', polyfill)\n  .factory('requestAnimation', requestAnimation)\n  .factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n  if(x < 0.5) {\n    return Math.pow(x*2, 2)/2;\n  }\n  return 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n  var proto = angular.element.prototype;\n\n  var isDocument = function(el) {\n    return (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n  };\n\n  var isElement = function(el) {\n    return (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n  };\n\n  var unwrap = function(el) {\n    return isElement(el) || isDocument(el) ? el : el[0];\n  };\n\n  proto.scrollTo = function(left, top, duration) {\n    var aliasFn;\n    if(angular.isElement(left)) {\n      aliasFn = this.scrollToElement;\n    } else if(duration) {\n      aliasFn = this.scrollToAnimated;\n    }\n    if(aliasFn) {\n      return aliasFn.apply(this, arguments);\n    }\n    var el = unwrap(this);\n    if(isDocument(el)) {\n      return $window.scrollTo(left, top);\n    }\n    el.scrollLeft = left;\n    el.scrollTop = top;\n  };\n\n  proto.scrollToAnimated = function(left, top, duration, easing) {\n    var scrollAnimation, deferred;\n    if(duration && !easing) {\n      easing = scrollEasing;\n    }\n    var startLeft = this.scrollLeft(),\n      startTop = this.scrollTop(),\n      deltaLeft = Math.round(left - startLeft),\n      deltaTop = Math.round(top - startTop);\n\n    var startTime = null;\n    var el = this;\n\n    var cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n    var cancelScrollAnimation = function($event) {\n      if (!$event || $event.which > 0) {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        cancelAnimation(scrollAnimation);\n        deferred.reject();\n        scrollAnimation = null;\n      }\n    };\n\n    if(scrollAnimation) {\n      cancelScrollAnimation();\n    }\n    deferred = $q.defer();\n\n    if(!deltaLeft && !deltaTop) {\n      deferred.resolve();\n      return deferred.promise;\n    }\n\n    var animationStep = function(timestamp) {\n      if (startTime === null) {\n        startTime = timestamp;\n      }\n\n      var progress = timestamp - startTime;\n      var percent = (progress >= duration ? 1 : easing(progress/duration));\n\n      el.scrollTo(\n        startLeft + Math.ceil(deltaLeft * percent),\n        startTop + Math.ceil(deltaTop * percent)\n      );\n      if(percent < 1) {\n        scrollAnimation = requestAnimation(animationStep);\n      } else {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        scrollAnimation = null;\n        deferred.resolve();\n      }\n    };\n\n    //Fix random mobile safari bug when scrolling to top by hitting status bar\n    el.scrollTo(startLeft, startTop);\n\n    // el.bind(cancelOnEvents, cancelScrollAnimation);\n\n    scrollAnimation = requestAnimation(animationStep);\n    return deferred.promise;\n  };\n\n  proto.scrollToElement = function(target, offset, duration, easing) {\n    var el = unwrap(this);\n    var top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n    if(isElement(el)) {\n      top -= el.getBoundingClientRect().top;\n    }\n    return this.scrollTo(0, top, duration, easing);\n  };\n\n  var overloaders = {\n    scrollLeft: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(value, this.scrollTop(), duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n      }\n      return el.scrollLeft;\n    },\n    scrollTop: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(this.scrollTop(), value, duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n      }\n      return el.scrollTop;\n    }\n  };\n\n  //Add duration and easing functionality to existing jQuery getter/setters\n  var overloadScrollPos = function(superFn, overloadFn) {\n    return function(value, duration) {\n      if(duration) {\n        return overloadFn.apply(this, arguments);\n      }\n      return superFn.apply(this, arguments);\n    };\n  };\n\n  for(var methodName in overloaders) {\n    proto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n  }\n}\nrunFn.$inject = [\"$window\", \"$q\", \"cancelAnimation\", \"requestAnimation\", \"scrollEasing\"];\n\n/* @ngInject */\nfunction polyfill ($window) {\n  var vendors = ['webkit', 'moz', 'o', 'ms'];\n\n  return function(fnName, fallback) {\n    if($window[fnName]) {\n      return $window[fnName];\n    }\n    var suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n    for(var key, i = 0; i < vendors.length; i++) {\n      key = vendors[i]+suffix;\n      if($window[key]) {\n        return $window[key];\n      }\n    }\n    return fallback;\n  };\n}\npolyfill.$inject = [\"$window\"];\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n  var lastTime = 0;\n  var fallback = function(callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = $timeout(function() {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  return polyfill('requestAnimationFrame', fallback);\n}\nrequestAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n  var fallback = function(promise) {\n    $timeout.cancel(promise);\n  };\n\n  return polyfill('cancelAnimationFrame', fallback);\n}\ncancelAnimation.$inject = [\"polyfill\", \"$timeout\"];\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel-group directive\n *\n * Container for set of 'ak-panel' directives that maintains the panels state and all interactions with the group\n *\n * @attribute name (optional) String: name of the group, to be referenced in ak-panel-group-menu's 'for' attribute\n * @attribute speed (optional) Number: duration in milliseconds to snap to the desired panel, defaults to 400ms\n * @attribute threshold (optional) Number: amount of pixels required to scroll before snapping to the next panel, defults to 50px\n * @attribute fullWindow (optional) Boolean: true if the panels are to fill the full browser window\n * @attribute keyboard (optional) Boolean: true if key presses can be used to navigate panels\n * @attribute prevKey (optional) Number: keyCode of key to navigate to previous panel, defaults to 38 (up arrow)\n * @attribute nextKey (optional) Number: keyCode of key to navigate to next panel, defaults to 40 (down arrow)\n * @attribute snap (optional) Boolean: enable or disable the snapping on initialization\n */\nangular\n  .module('panel-snap')\n  .directive('akPanelGroup', akPanelGroup)\n  .controller('PanelGroupController', panelGroupController);\n\n/* @ngInject */\nfunction akPanelGroup () {\n  return {\n    restrict: 'EA',\n    replace: true,\n    controller: 'PanelGroupController',\n    scope: {\n      name: '@',\n      speed: '=',\n      threshold: '=',\n      fullWindow: '=',\n      keyboard: '=',\n      prevKey: '=',\n      nextKey: '=',\n      snap: '='\n    },\n    link: function (scope) {\n      // Call init after child panels have registered with the controller\n      scope.init();\n    }\n  };\n}\n\n/* @ngInject */\nfunction panelGroupController ($scope, $element, $attrs, $window, $timeout, $document, $rootScope) {\n  var ctrl = this;\n\n  var resizeTimeout;\n  var scrollTimeout;\n\n  ctrl.panels = [];\n\n  ctrl.currentPanel = 0;\n  ctrl.scrollInterval = 0;\n  ctrl.scrollOffset = 0;\n  ctrl.isSnapping = false;\n  ctrl.enabled = true;\n\n  ctrl.speed = 400;   // default snap animation duration in milliseconds\n  ctrl.threshold = 50;  // default pixel threshold for snap to occur in pixels\n  ctrl.prevKey = 38;    // default prevKey key code - up arrow\n  ctrl.nextKey = 40;    // default nextKey key code - down arrow\n\n  /*\n   * add a panels scope to the panels array\n   * - attached to `this` so it can be called from child panel directives\n   */\n  ctrl.addPanel = function (panelScope) {\n    var panelName = angular.isDefined(panelScope.name) ? panelScope.name : 'Panel ' + (ctrl.panels.length + 1);\n    ctrl.panels.push(panelScope);\n    if (angular.isDefined($scope.name)) {\n      $rootScope.$emit('panelsnap:addedPanel', { group: $scope.name, name: panelName, id: ctrl.panels.length-1 });\n    }\n  };\n\n  /*\n   * enable snapping\n   */\n  ctrl.enableSnap = function () {\n    // TODO: should this snap to closest panel when enabled? (yes)\n    ctrl.enabled = true;\n  };\n\n  /*\n   * disable snapping\n   */\n  ctrl.disableSnap = function () {\n    ctrl.enabled = false;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.toggleSnap = function () {\n    ctrl.enabled = !ctrl.enabled;\n  };\n\n  /*\n   * toggle snapping\n   */\n  ctrl.snapTo = function (id) {\n    snapToPanel(id);\n  };\n\n  /*\n   * initialise the controller state\n   * - called from the directive link function. This ensures it is called after any child panels\n   *  link function has called addPanel and therefore the panels array is filled and valid.\n   */\n  $scope.init = function () {\n    ctrl.container = $element;\n    ctrl.eventContainer = ctrl.container;\n    ctrl.snapContainer = ctrl.container;\n\n    // if full window, bind and snap using document instead of element\n    if ($scope.fullWindow) {\n      ctrl.container = angular.element($document[0].documentElement);\n      ctrl.eventContainer = ctrl.snapContainer = $document;\n    }\n\n    // set options / variables\n    ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n    ctrl.speed = angular.isDefined($scope.speed) ? $scope.speed : ctrl.speed;\n    ctrl.threshold = angular.isDefined($scope.threshold) ? $scope.threshold : ctrl.threshold;\n    ctrl.prevKey = angular.isDefined($scope.prevKey) ? $scope.prevKey : ctrl.prevKey;\n    ctrl.nextKey = angular.isDefined($scope.nextKey) ? $scope.nextKey : ctrl.nextKey;\n    ctrl.enabled = angular.isDefined($scope.snap) ? $scope.snap : ctrl.enabled;\n\n    bind();\n    $timeout(function() {\n      activatePanel(ctrl.currentPanel);\n    },0);\n  };\n\n  /*\n   * listen for selectPanel event, if group name matches then snap\n   * to the target panel\n   */\n  $rootScope.$on('panelsnap:selectPanel', function (event, data) {\n    if ($scope.name === data.group) {\n      event.stopPropagation();\n      snapToPanel(data.id);\n    }\n  });\n\n  $scope.$on('$destroy',function(){\n    angular.element(document).unbind('.panelsnap');\n  });\n\n  function bind() {\n    // bind scrolling events\n    ctrl.eventContainer.on('scroll.panelsnap', scrollFn);\n\n    // bind scrolling events\n    if(ctrl.enabled) {\n      // touch move direction support\n      var touchstart;\n      ctrl.eventContainer.on('touchstart.panelsnap', function(e) {\n        touchstart = e.originalEvent.touches[0].clientY;\n      });\n      ctrl.eventContainer.on('mousewheel.panelsnap touchmove.panelsnap DOMMouseScroll.panelsnap', function(e) {\n        e.preventDefault();\n        if(ctrl.isSnapping) return false;\n        if(e.type==='mousewheel'||e.type==='DOMMouseScroll') {\n          var delta = Math.max(-1, Math.min(1, (e.originalEvent.wheelDelta || -e.originalEvent.detail)));\n          if(delta && delta > 0) snapToPanel(ctrl.currentPanel - 1);\n          else if(delta) snapToPanel(ctrl.currentPanel + 1);\n        } else if(e.type==='touchmove') {\n          var touchend = e.originalEvent.changedTouches[0].clientY;\n          if(touchstart < touchend) snapToPanel(ctrl.currentPanel - 1);\n          else snapToPanel(ctrl.currentPanel + 1);\n          touchstart = touchend;\n        }\n      });\n    }\n\n    // bind resize event\n    angular.element($window).on('resize.panelSnap', resize);\n\n    // bind keyboard events\n    if ($scope.keyboard) {\n      angular.element($window).on('keydown.panelSnap', keydown);\n    }\n  }\n\n  function keydown(e) {\n    if (!ctrl.enabled) {\n      return;\n    }\n\n    // prevent any keypress events while snapping\n    if (ctrl.isSnapping) {\n      if (e.which === ctrl.prevKey || e.which === ctrl.nextKey) {\n        e.preventDefault();\n        return false;\n      }\n      return;\n    }\n\n    switch (e.which) {\n      case ctrl.prevKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel - 1);\n        break;\n      case ctrl.nextKey:\n        e.preventDefault();\n        snapToPanel(ctrl.currentPanel + 1);\n        break;\n    }\n  }\n\n  function scrollFn() {\n    if (!ctrl.enabled) scrollStop();\n    $timeout.cancel(scrollTimeout);\n    scrollTimeout = $timeout(function () {\n      scrollStop();\n    }, 50);\n  }\n\n  function resize() {\n    var threshold = 150;\n    $timeout.cancel(resizeTimeout);\n    resizeTimeout = $timeout(function () {\n      ctrl.scrollInterval = isNaN(ctrl.container[0].innerHeight) ? ctrl.container[0].clientHeight : ctrl.container[0].innerHeight;\n\n      if (!ctrl.enabled) {\n        return;\n      }\n\n      // snap back to current panel after resizing\n      snapToPanel(ctrl.currentPanel);\n    }, threshold);\n  }\n\n  function scrollStop() {\n\n    // if (ctrl.isMouseDown) {\n    //  return;\n    // }\n\n    if (ctrl.isSnapping) {\n      return;\n    }\n\n    var target;\n    var offset = ctrl.snapContainer.scrollTop();\n\n\n    // still want to activate the correct panel even if snapping is disabled\n    angular.forEach(ctrl.panels, function(panel,i) { if(panel.position < offset + ctrl.scrollInterval/2) target = i; });\n    if (target !== ctrl.currentPanel) $scope.$apply(activatePanel(target));\n    if (!ctrl.enabled) return true;\n\n    var scrollDifference = offset - ctrl.scrollOffset;\n    var maxOffset = ctrl.container[0].scrollHeight - ctrl.scrollInterval;\n\n    // determine target panel\n    if (scrollDifference < -ctrl.threshold && scrollDifference > -ctrl.scrollInterval) {\n      target = Math.floor(offset / ctrl.scrollInterval);\n    } else if (scrollDifference > ctrl.threshold && scrollDifference < ctrl.scrollInterval) {\n      target = Math.ceil(offset / ctrl.scrollInterval);\n    } else {\n      target = Math.round(offset / ctrl.scrollInterval);\n    }\n\n    // ensure target is within panel array bounds\n    target = Math.max(0, Math.min(target, ctrl.panels.length - 1));\n\n    if (scrollDifference === 0) {\n      // Do nothing\n    } else if (offset <= 0 || offset >= maxOffset) {\n      // only activate to prevent stuttering\n      activatePanel(target);\n      // set a scrollOffset to a sane number for next scroll\n      ctrl.scrollOffset = offset <= 0 ? 0 : maxOffset;\n    } else {\n      snapToPanel(target);\n    }\n  }\n\n  function snapToPanel(target) {\n    if (isNaN(target) || target < 0 || target >= ctrl.panels.length) {\n      return;\n    }\n\n    ctrl.isSnapping = true;\n\n    $rootScope.$broadcast('panelsnap:start', { group: $scope.name, id: target });\n    $timeout(function() { // lets the broadcast get processed before continuing\n      ctrl.panels[ctrl.currentPanel].onLeave();\n\n      var scrollTarget = ctrl.scrollInterval * target;\n      ctrl.snapContainer.scrollTo(0, scrollTarget, ctrl.speed).then(function () {\n        ctrl.scrollOffset = scrollTarget;\n        $timeout(function(){\n          ctrl.isSnapping = false;\n        },300);\n\n\n        $rootScope.$broadcast('panelsnap:finish', { group: $scope.name, id: target });\n        ctrl.panels[target].onEnter();\n\n        activatePanel(target);\n      });\n    },0);\n  }\n\n  function activatePanel(target) {\n    // if no panels, or panels have not yet loaded (within ng-repeat) return\n    if (!ctrl.panels || ctrl.panels.length < 1) {\n      return;\n    }\n\n    angular.forEach(ctrl.panels, function (panel) {\n      panel.setActive(false);\n    });\n    ctrl.panels[target].setActive(true);\n    ctrl.currentPanel = target;\n\n    // TODO: call onActivate function for target\n    $rootScope.$broadcast('panelsnap:activate', {group: $scope.name, id: target });\n    $rootScope.$emit('panelsnap:activatePanel', { group: $scope.name, id: target });\n  }\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * ak-panel directive\n *\n * Creates a panel inside an ak-panel-group directive. Must be a child of an ak-panel-group element.\n *\n * @attribute name (optional) String: name of panel, will form text of nav element in any ak-panel-group-menu's assocaited with the containing group\n * @attribute onEnter (optional) Function: function to be called when panel is snapped into\n * @attribute onLeave (optional) Function: function to be called when panel is snapped out of\n */\nangular\n  .module('panel-snap')\n  .directive('akPanel', akPanel);\n\n/* @ngInject */\nfunction akPanel () {\n  return {\n    restrict: 'EA',\n    require: '^akPanelGroup',\n    replace: true,\n    transclude: true,\n    scope: {\n      name: '@',\n      onEnter: '&',\n      onLeave: '&'\n    },\n    template: '<div class=\"ak-panel\" ng-class=\"{active: active}\" ng-transclude></div>',\n    link: function (scope, element, attrs, ctrl) {\n\n      // add to parent ak-panel-group\n      ctrl.addPanel(scope);\n\n      // default panel styles\n      element.css({\n        'width': '100%',\n        'height': '100%',\n        'position': 'relative'\n      });\n\n      // attach enable/disable scroll methods to scope - need be accessed by $parent due to transclude scope\n      scope.enableSnap = ctrl.enableSnap;\n      scope.disableSnap = ctrl.disableSnap;\n      scope.toggleSnap = ctrl.toggleSnap;\n      scope.snapTo = ctrl.snapTo;\n\n      // active flag and getter function, to set class .active on panel\n      scope.active = false;\n      scope.setActive = function (active) {\n        scope.active = active;\n      };\n\n      var onResize = function() {\n        // TODO replace jQuery offset here\n        scope.position = $(element).offset().top;\n      };\n      onResize();\n\n      // bind resize event\n      angular.element(window).on('resize', onResize);\n      scope.$on('$destroy',function(){\n        angular.element(window).unbind('resize', onResize);\n      });\n\n    }\n  };\n}\n\n\n})();\n","(function() {\n'use strict';\n\n/*\n * Scroll methods - removes the need for external jQuery or GreenSock libraries\n *\n * Adapted from durated's Angular Scroll module\n * https://github.com/durated/angular-scroll\n */\nangular\n  .module('panel-snap')\n  .value('scrollEasing', scrollEasing)\n  .run(runFn)\n  .factory('polyfill', polyfill)\n  .factory('requestAnimation', requestAnimation)\n  .factory('cancelAnimation', cancelAnimation);\n\nfunction scrollEasing (x) {\n  if(x < 0.5) {\n    return Math.pow(x*2, 2)/2;\n  }\n  return 1-Math.pow((1-x)*2, 2)/2;\n}\n\n/* @ngInject */\nfunction runFn ($window, $q, cancelAnimation, requestAnimation, scrollEasing) {\n  var proto = angular.element.prototype;\n\n  var isDocument = function(el) {\n    return (typeof HTMLDocument !== 'undefined' && el instanceof HTMLDocument) || (el.nodeType && el.nodeType === el.DOCUMENT_NODE);\n  };\n\n  var isElement = function(el) {\n    return (typeof HTMLElement !== 'undefined' && el instanceof HTMLElement) || (el.nodeType && el.nodeType === el.ELEMENT_NODE);\n  };\n\n  var unwrap = function(el) {\n    return isElement(el) || isDocument(el) ? el : el[0];\n  };\n\n  proto.scrollTo = function(left, top, duration) {\n    var aliasFn;\n    if(angular.isElement(left)) {\n      aliasFn = this.scrollToElement;\n    } else if(duration) {\n      aliasFn = this.scrollToAnimated;\n    }\n    if(aliasFn) {\n      return aliasFn.apply(this, arguments);\n    }\n    var el = unwrap(this);\n    if(isDocument(el)) {\n      return $window.scrollTo(left, top);\n    }\n    el.scrollLeft = left;\n    el.scrollTop = top;\n  };\n\n  proto.scrollToAnimated = function(left, top, duration, easing) {\n    var scrollAnimation, deferred;\n    if(duration && !easing) {\n      easing = scrollEasing;\n    }\n    var startLeft = this.scrollLeft(),\n      startTop = this.scrollTop(),\n      deltaLeft = Math.round(left - startLeft),\n      deltaTop = Math.round(top - startTop);\n\n    var startTime = null;\n    var el = this;\n\n    var cancelOnEvents = 'scroll mousedown mousewheel touchmove keydown';\n    var cancelScrollAnimation = function($event) {\n      if (!$event || $event.which > 0) {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        cancelAnimation(scrollAnimation);\n        deferred.reject();\n        scrollAnimation = null;\n      }\n    };\n\n    if(scrollAnimation) {\n      cancelScrollAnimation();\n    }\n    deferred = $q.defer();\n\n    if(!deltaLeft && !deltaTop) {\n      deferred.resolve();\n      return deferred.promise;\n    }\n\n    var animationStep = function(timestamp) {\n      if (startTime === null) {\n        startTime = timestamp;\n      }\n\n      var progress = timestamp - startTime;\n      var percent = (progress >= duration ? 1 : easing(progress/duration));\n\n      el.scrollTo(\n        startLeft + Math.ceil(deltaLeft * percent),\n        startTop + Math.ceil(deltaTop * percent)\n      );\n      if(percent < 1) {\n        scrollAnimation = requestAnimation(animationStep);\n      } else {\n        el.unbind(cancelOnEvents, cancelScrollAnimation);\n        scrollAnimation = null;\n        deferred.resolve();\n      }\n    };\n\n    //Fix random mobile safari bug when scrolling to top by hitting status bar\n    el.scrollTo(startLeft, startTop);\n\n    // el.bind(cancelOnEvents, cancelScrollAnimation);\n\n    scrollAnimation = requestAnimation(animationStep);\n    return deferred.promise;\n  };\n\n  proto.scrollToElement = function(target, offset, duration, easing) {\n    var el = unwrap(this);\n    var top = this.scrollTop() + unwrap(target).getBoundingClientRect().top - (offset || 0);\n    if(isElement(el)) {\n      top -= el.getBoundingClientRect().top;\n    }\n    return this.scrollTo(0, top, duration, easing);\n  };\n\n  var overloaders = {\n    scrollLeft: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(value, this.scrollTop(), duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft;\n      }\n      return el.scrollLeft;\n    },\n    scrollTop: function(value, duration, easing) {\n      if(angular.isNumber(value)) {\n        return this.scrollTo(this.scrollTop(), value, duration, easing);\n      }\n      var el = unwrap(this);\n      if(isDocument(el)) {\n        return $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop;\n      }\n      return el.scrollTop;\n    }\n  };\n\n  //Add duration and easing functionality to existing jQuery getter/setters\n  var overloadScrollPos = function(superFn, overloadFn) {\n    return function(value, duration) {\n      if(duration) {\n        return overloadFn.apply(this, arguments);\n      }\n      return superFn.apply(this, arguments);\n    };\n  };\n\n  for(var methodName in overloaders) {\n    proto[methodName] = (proto[methodName] ? overloadScrollPos(proto[methodName], overloaders[methodName]) : overloaders[methodName]);\n  }\n}\n\n/* @ngInject */\nfunction polyfill ($window) {\n  var vendors = ['webkit', 'moz', 'o', 'ms'];\n\n  return function(fnName, fallback) {\n    if($window[fnName]) {\n      return $window[fnName];\n    }\n    var suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1);\n    for(var key, i = 0; i < vendors.length; i++) {\n      key = vendors[i]+suffix;\n      if($window[key]) {\n        return $window[key];\n      }\n    }\n    return fallback;\n  };\n}\n\n/* @ngInject */\nfunction requestAnimation (polyfill, $timeout) {\n  var lastTime = 0;\n  var fallback = function(callback) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = $timeout(function() {\n      callback(currTime + timeToCall);\n    }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n\n  return polyfill('requestAnimationFrame', fallback);\n}\n\n/* @ngInject */\nfunction cancelAnimation (polyfill, $timeout) {\n  var fallback = function(promise) {\n    $timeout.cancel(promise);\n  };\n\n  return polyfill('cancelAnimationFrame', fallback);\n}\n\n\n})();\n"],"sourceRoot":"/source/"}